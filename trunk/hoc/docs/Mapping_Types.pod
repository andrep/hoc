=head1 Mapping Objective-C Concepts to Haskell's Type System

=head2 A Simple Example: I<NSMovie>


=head2 Objective-C Objects

=head3 Classes

=head3 Protocols

=begin comment

Yes, formal protocols. Luckily, they're very rarely used in
Cocoa.  It's only an ifgen issue; the current ifgen just
generates ID for all id<Foo> types.  For id<Foo,Bar> used as
a parameter, it should generate (Foo (ID a), Bar (ID a)) => ID a.
For return values id<Foo,Bar>, we'll have to define a special
type ID_Bar_Foo and declare instances for Foo and Bar for it. The
only difficult part should be to avoid defining those types too
often...

=end comment

=head3 Protocol Adoptions

=head2 Object Messaging

=head3 Selectors

=head3 Methods

=head3 Sending Messages to Objects

=head4 Do not Resist the Monad

=head2 Miscellanea

=head3 Autorelease Pools

=head3 C<enum> Types

=head3 C<struct> Types

=head3 Ambiguous Function Names

Some functions have the same name and are defined in more than
one class: e.g. the I<NSProcessInfo>, I<NSScriptCommand> and
I<NSTask> classes all define a method named C<arguments>.  Any
such multiply-occuring method names are not exported from the
top-level framework module (I<Foundation> or I<AppKit>) by
default: you will need to import the class specifically, e.g.
C<import Foundation.NSProcessInfo> to import I<NSProcessInfo>'s
C<arguments> function.

If you wish to use the C<arguments> method from multiple classes,
use the C<import qualified> or C<import X as Y> constructs, just
as if you were importing a same-named function from different
Haskell modules normally.

=for comment Modeline for vi(m)
vi:sw=2 tw=65

